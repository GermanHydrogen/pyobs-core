#!/usr/bin/env python3
import signal
import threading
import time

import matplotlib
import argparse
import logging
from logging.handlers import TimedRotatingFileHandler
import os
from io import StringIO
import sys
import yaml

from pyobs.interfaces import IConfigProvider
from pyobs.object import get_object
from pyobs.comm import Comm
from pyobs.comm.xmpp import XmppComm
from pyobs.utils.config import pre_process_yaml

matplotlib.use('Agg')


def hack_threading():
    """Bad hack to set thread name on OS level."""
    try:
        import prctl

        def set_thread_name(name):
            prctl.set_name(name)

        def _thread_name_hack(self):
            set_thread_name(self.name)
            threading.Thread.__bootstrap_original__(self)

        threading.Thread.__bootstrap_original__ = threading.Thread._bootstrap
        threading.Thread._bootstrap = _thread_name_hack

    except ImportError:
        log = logging.getLogger('pyobs')
        log.warning('prctl module is not installed. You will not be able to see thread names')

        def set_thread_name(name):
            pass


def start_daemon(pid_file=None, *args, **kwargs):
    import daemon
    from daemon import pidfile

    # get run directory
    run_dir = os.path.dirname(pid_file)

    # This launches the daemon in its context
    with daemon.DaemonContext(
            working_directory=run_dir,
            umask=0o002,
            pidfile=pidfile.TimeoutPIDLockFile(pid_file)) as context:
        run(*args, **kwargs)


def run(config=None, log_file: str = None, log_level: str = 'info', log_rotate: bool = False, gui: bool = False,
        username: str = None, password: str = None, server: str = None, comm: str = None, *args, **kwargs):
    # formatter for logging
    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(filename)s:%(lineno)d %(message)s')

    # handlers
    handlers = []

    # stdout
    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    handlers.append(stream_handler)

    # file
    if log_file is not None:
        if log_rotate:
            file_handler = TimedRotatingFileHandler(log_file, when='W0')
        else:
            file_handler = logging.FileHandler(log_file, mode='a')
        file_handler.setFormatter(formatter)
        handlers.append(file_handler)

    # basic setup
    logging.basicConfig(handlers=handlers, level=logging.getLevelName(log_level.upper()))
    logging.captureWarnings(True)

    # disable tornado logger
    logging.getLogger('tornado.access').disabled = True

    # get pyobs logger
    log = logging.getLogger('pyobs')

    if gui:
        # import Qt stuff
        from PyQt5.QtWidgets import QApplication
        from pyobs.utils.modulegui import ModuleGui

        # create Qt app and window
        qapp = QApplication(sys.argv)
        wnd = ModuleGui()

    # hack threading to set thread names on OS level
    hack_threading()

    # do we have a config?
    if config:
        # yes, load it
        log.info('Loading configuration from {0:s}...'.format(config))
        with StringIO(pre_process_yaml(config)) as f:
            cfg = yaml.load(f)

    else:
        # create empty config
        cfg = {}

    # comm config
    username = os.environ['USERNAME'] if username is None and 'USERNAME' in os.environ else username
    password = os.environ['PASSWORD'] if password is None and 'PASSWORD' in os.environ else password
    server = os.environ['SERVER'] if server is None and 'SERVER' in os.environ else server
    if username and password and comm == 'xmpp':
        # create comm object from command line or environment
        comm = XmppComm(jid=username, password=password, server=server)
    else:
        # create comm object from config
        comm = get_object(cfg['comm'])

    # open comm and wait a little
    log.info('Opening connection to server...')
    comm.open()

    # remove comm from config
    if 'comm' in cfg:
        del cfg['comm']

    # do we have a class definition?
    if 'class' not in cfg:
        cfg = get_network_config(comm, log, attempts=2)

    # no config?
    if not cfg:
        log.error('No configuration found.')
        comm.close()
        sys.exit(1)

    # create application
    log.info('Creating objects...')
    module = get_object(cfg, comm=comm)
    try:
        module.open()
    except:
        log.exception('Could not initialize app.')
        module.close()
        comm.close()
        sys.exit(1)

    # run it
    if gui:
        # run qt application
        wnd.show()
        qapp.exec()
    else:
        # add signal handler
        def signal_handler(signum, frame):
            module.quit()
        signal.signal(signal.SIGTERM, signal_handler)
        signal.signal(signal.SIGINT, signal_handler)

        # run app
        module.run()

    # close
    module.close()
    comm.close()

    # finished
    log.info('Finished shutting down.')


def get_network_config(comm: Comm, log, attempts=10, wait_time=2):
    # find IConfigProvider
    log.info('No module definition found, trying to find a config provider...')
    for client in comm.clients:
        proxy = comm[client] # type: Proxy

    for client in comm.clients_with_interface(IConfigProvider):
        try:
            # get proxy
            proxy = comm[client]    # type: IConfigProvider

            # get config
            cfg = proxy.get_config(comm.name)
            break

        except FileNotFoundError:
            pass
    else:
        # no config found
        cfg = {}

    # if we didn't get a config and there are attempts left, try again
    if not cfg and attempts > 0:
        # sleep a little
        log.warning('No config found, trying to connect again in %d seconds...', wait_time)
        time.sleep(wait_time)

        # try again
        cfg = get_network_config(comm, log, attempts=attempts - 1, wait_time=wait_time)

    # return whatever we got
    return cfg


def main():
    # argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('config', type=str, help='Configuration file', nargs='?')

    # logging
    parser.add_argument('--log-level', type=str, choices=['critical', 'error', 'warning', 'info', 'debug'],
                        default='info')
    parser.add_argument('-l', '--log-file', type=str, help='file to write log into')
    parser.add_argument('--log-rotate', action='store_true', help='rotate logs automatically')

    # write pid file as daemon
    parser.add_argument('-p', '--pid-file', type=str)

    # show gui
    parser.add_argument('--gui', action='store_true', help='run in a GUI instead of a terminal')

    # comm
    parser.add_argument('--username', type=str, help='Username for connecting to server')
    parser.add_argument('--password', type=str, help='Password for connecting to server')
    parser.add_argument('--server', type=str, help='server:port for server to connect to')
    parser.add_argument('--comm', type=str, choices=['xmpp'], default='xmpp')

    # parse args
    args = parser.parse_args()

    # --gui and --pid-file don't work together
    if args.gui and args.pid_file:
        print('--gui and --pid-file cannot be used together.')
        return

    # get full path of config
    if args.config:
        args.config = os.path.abspath(args.config)

    # run it
    if args.pid_file:
        start_daemon(**vars(args))
    else:
        run(**vars(args))


if __name__ == '__main__':
    main()
