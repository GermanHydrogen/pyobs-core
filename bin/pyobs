#!/usr/bin/env python3
import signal
import threading
import matplotlib
import argparse
import logging
from logging.handlers import TimedRotatingFileHandler
import os
from io import StringIO
import sys
import yaml

from pyobs.object import get_object
from pyobs.comm.xmpp import XmppComm
from pyobs.utils.config import pre_process_yaml

matplotlib.use('Agg')


def hack_threading():
    """Bad hack to set thread name on OS level."""
    try:
        import prctl

        def set_thread_name(name):
            prctl.set_name(name)

        def _thread_name_hack(self):
            set_thread_name(self.name)
            threading.Thread.__bootstrap_original__(self)

        threading.Thread.__bootstrap_original__ = threading.Thread._bootstrap
        threading.Thread._bootstrap = _thread_name_hack

    except ImportError:
        log = logging.getLogger('pyobs')
        log.warning('prctl module is not installed. You will not be able to see thread names')

        def set_thread_name(name):
            pass


def start_daemon(pid_file=None, *args, **kwargs):
    import daemon
    from daemon import pidfile

    # get run directory
    run_dir = os.path.dirname(pid_file)

    # This launches the daemon in its context
    with daemon.DaemonContext(
            working_directory=run_dir,
            umask=0o002,
            pidfile=pidfile.TimeoutPIDLockFile(pid_file)) as context:
        run(*args, **kwargs)


def run(config=None, log_file: str = None, log_level: str = 'info', log_rotate: bool = False, gui: bool = False,
        username: str = None, password: str = None, server: str = None, comm: str = None, *args, **kwargs):
    # formatter for logging
    formatter = logging.Formatter('%(asctime)s [%(levelname)s] %(filename)s:%(lineno)d %(message)s')

    # handlers
    handlers = []

    # stdout
    stream_handler = logging.StreamHandler()
    stream_handler.setFormatter(formatter)
    handlers.append(stream_handler)

    # file
    if log_file is not None:
        if log_rotate:
            file_handler = TimedRotatingFileHandler(log_file, when='W0')
        else:
            file_handler = logging.FileHandler(log_file, mode='a')
        file_handler.setFormatter(formatter)
        handlers.append(file_handler)

    # basic setup
    logging.basicConfig(handlers=handlers, level=logging.getLevelName(log_level.upper()))
    logging.captureWarnings(True)

    # disable tornado logger
    logging.getLogger('tornado.access').disabled = True

    # get pyobs logger
    log = logging.getLogger('pyobs')

    if gui:
        # import Qt stuff
        from PyQt5.QtWidgets import QApplication
        from pyobs.utils.modulegui import ModuleGui

        # create Qt app and window
        qapp = QApplication(sys.argv)
        wnd = ModuleGui()

    # hack threading to set thread names on OS level
    hack_threading()

    # load config
    log.info('Loading configuration from {0:s}...'.format(config))
    with StringIO(pre_process_yaml(config)) as f:
        cfg = yaml.load(f)

    # comm config
    username = os.environ['USERNAME'] if username is None and 'USERNAME' in os.environ else username
    password = os.environ['PASSWORD'] if password is None and 'PASSWORD' in os.environ else password
    server = os.environ['SERVER'] if server is None and 'SERVER' in os.environ else server
    if username and password and comm == 'xmpp':
        cfg['comm'] = XmppComm(jid=username, password=password, server=server)

    # create application
    log.info('Creating objects...')
    app = get_object(cfg)
    try:
        app.open()
    except:
        log.exception('Could not initialize app.')
        app.close()
        sys.exit(1)

    # run it
    if gui:
        # run qt application
        wnd.show()
        qapp.exec()
    else:
        # add signal handler
        def signal_handler(signum, frame):
            app.quit()
        signal.signal(signal.SIGTERM, signal_handler)
        signal.signal(signal.SIGINT, signal_handler)

        # run app
        app.run()

    # close
    app.close()

    # finished
    log.info('Finished shutting down.')


def main():
    # argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('config', type=str, help='Configuration file')

    # logging
    parser.add_argument('--log-level', type=str, choices=['critical', 'error', 'warning', 'info', 'debug'],
                        default='info')
    parser.add_argument('-l', '--log-file', type=str, help='file to write log into')
    parser.add_argument('--log-rotate', action='store_true', help='rotate logs automatically')

    # write pid file as daemon
    parser.add_argument('-p', '--pid-file', type=str)

    # show gui
    parser.add_argument('--gui', action='store_true', help='run in a GUI instead of a terminal')

    # comm
    parser.add_argument('--username', type=str, help='Username for connecting to server')
    parser.add_argument('--password', type=str, help='Password for connecting to server')
    parser.add_argument('--server', type=str, help='server:port for server to connect to')
    parser.add_argument('--comm', type=str, choices=['xmpp'], default='xmpp')

    # parse args
    args = parser.parse_args()

    # --gui and --pid-file don't work together
    if args.gui and args.pid_file:
        print('--gui and --pid-file cannot be used together.')
        return

    # get full path of config
    args.config = os.path.abspath(args.config)

    # run it
    if args.pid_file:
        start_daemon(**vars(args))
    else:
        run(**vars(args))


if __name__ == '__main__':
    main()
